// Code generated by senseBox Blockly on Fri Jan 31 2025 15:43:22 GMT+0100 (Central European Standard Time)

#include <Wire.h>
#include <Adafruit_GFX.h> // http://librarymanager/All#Adafruit_GFX_Library
#include <Adafruit_SSD1306.h> // http://librarymanager/All#Adafruit_SSD1306
#include <vl53l8cx.h>

VL53L8CX sensor_vl53l8cx(&Wire, -1, -1);

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#include <FluxGarage_RoboEyes.h>
roboEyes roboEyes; // create RoboEyes instance

long update_interval = 75;
long start_time = 0;
long actual_time = 0;


void setup() {
  Serial.begin(9600);

  delay(1000);
  Wire.begin();
  Wire.setClock(1000000); //Sensor has max I2C freq of 1MHz
  sensor_vl53l8cx.begin();
  sensor_vl53l8cx.init();
  sensor_vl53l8cx.set_ranging_frequency_hz(30);
  sensor_vl53l8cx.set_resolution(VL53L8CX_RESOLUTION_8X8);
  sensor_vl53l8cx.start_ranging();
  Wire.setClock(100000); //Sensor has max I2C freq of 1MHz

  // Startup OLED Display
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3D)) { // Address 0x3C or 0x3D
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  // Startup robo eyes
  roboEyes.begin(SCREEN_WIDTH, SCREEN_HEIGHT, 100); // screen-width, screen-height, max framerate

  // Define some automated eyes behaviour
  roboEyes.setAutoblinker(ON, 3, 2); // Start auto blinker animation cycle -> bool active, int interval, int variation -> turn on/off, set interval between each blink in full seconds, set range for random interval variation in full seconds
  // roboEyes.setIdleMode(ON, 2, 2); // Start idle animation cycle (eyes looking in random directions) -> turn on/off, set interval between each eye repositioning in full seconds, set range for random time interval variation in full seconds
  
  // Define eye shapes, all values in pixels
  //roboEyes.setWidth(36, 36); // byte leftEye, byte rightEye
  //roboEyes.setHeight(36, 36); // byte leftEye, byte rightEye
  //roboEyes.setBorderradius(8, 8); // byte leftEye, byte rightEye
  //roboEyes.setSpacebetween(10); // int space -> can also be negative

  // Cyclops mode
  //roboEyes.setCyclops(ON); // bool on/off -> if turned on, robot has only on eye

  // Define mood, curiosity and position
  //roboEyes.setMood(DEFAULT); // mood expressions, can be TIRED, ANGRY, HAPPY, DEFAULT
  //roboEyes.setPosition(DEFAULT); // cardinal directions, can be N, NE, E, SE, S, SW, W, NW, DEFAULT (default = horizontally and vertically centered)
  //roboEyes.setCuriosity(ON); // bool on/off -> when turned on, height of the outer eyes increases when moving to the very left or very right

  // Set horizontal or vertical flickering
  //roboEyes.setHFlicker(ON, 2); // bool on/off, byte amplitude -> horizontal flicker: alternately displacing the eyes in the defined amplitude in pixels
  //roboEyes.setVFlicker(ON, 2); // bool on/off, byte amplitude -> vertical flicker: alternately displacing the eyes in the defined amplitude in pixels

  // Play prebuilt oneshot animations
  //roboEyes.anim_confused(); // confused - eyes shaking left and right
  //roboEyes.anim_laugh(); // laughing - eyes shaking up and down
  
} // end of setup


int seen = -3;
unsigned char lastDirection = DEFAULT;
unsigned char lastLastDirection = DEFAULT;
void loop() {
  start_time = millis();
  if (start_time > actual_time + update_interval) {
    actual_time = millis();
    VL53L8CX_ResultsData Result;
    uint8_t NewDataReady = 0;
    uint8_t status;

    Wire.setClock(1000000); //Sensor has max I2C freq of 1MHz
    status = sensor_vl53l8cx.check_data_ready(&NewDataReady);
    Wire.setClock(100000); //Sensor has max I2C freq of 1MHz

    if ((!status) && (NewDataReady != 0)) {
      Wire.setClock(1000000); //Sensor has max I2C freq of 1MHz
      sensor_vl53l8cx.get_ranging_data(&Result);
      Wire.setClock(100000); //Sensor has max I2C freq of 1MHz
      int min_index = 0;
      uint16_t min_distance = (long)(&Result)->distance_mm[0];
      // Find the pixel with the smallest distance
      for (int i = 1; i < 64; i++) {
        if ((long)(&Result)->distance_mm[i] < min_distance) {
          min_distance = (long)(&Result)->distance_mm[i];
          min_index = i;
        }
      }
      if (min_distance < 400) {
        int row = min_index / 8;
        int col = min_index % 8;

        // Determine cardinal direction
        unsigned char direction;

        if (row == 3 || row == 4) {
          if (col == 3 || col == 4) {
              direction = DEFAULT;
          } else if (col < 3) {
              direction = W;
          } else {
              direction = E;
          }
        } else if (row < 3) {
          if (col == 3 || col == 4) {
              direction = S;
          } else if (col < 3) {
              direction = SW;
          } else {
              direction = SE;
          }
        } else {
          if (col == 3 || col == 4) {
              direction = N;
          } else if (col < 3) {
              direction = NW;
          } else {
              direction = NE;
          }
        }
        if (
          (lastDirection == N && direction == S) ||
          (lastDirection == S && direction == N) ||
          (lastDirection == E && direction == W) ||
          (lastDirection == W && direction == E) ||
          (lastDirection == NE && direction == SW) ||
          (lastDirection == SW && direction == NE) ||
          (lastDirection == NW && direction == SE) ||
          (lastDirection == SE && direction == NW)
        ) {
            direction = DEFAULT;
        }
        else if (
            (lastDirection == NW && direction == NE) ||
            (lastDirection == NE && direction == NW)
        ) {
            direction = N;
        }
        else if (
            (lastDirection == SW && direction == SE) ||
            (lastDirection == SE && direction == SW)
        ) {
            direction = S;
        }
        else if (
            (lastDirection == NW && direction == SW) ||
            (lastDirection == SW && direction == NW)
        ) {
            direction = W;
        }
        else if (
            (lastDirection == NE && direction == SE) ||
            (lastDirection == SE && direction == NE)
        ) {
            direction = E;
        }

        roboEyes.setPosition(direction);
        lastLastDirection = lastDirection;
        lastDirection = direction;
        if (min_distance < 120) {
          seen = min(seen+1,3);
        } else {
          if (seen>0) {
            seen--;
          } else if (seen<0) {
            seen++;
          }
        }
      } else {
        seen = max(seen-1,-3);
      }
    }
  }
  if (seen>=3) {
    roboEyes.setMood(HAPPY);
  } else if (seen==0) {
    roboEyes.setMood(DEFAULT);
  } else if (seen<=-3) {
    roboEyes.setMood(TIRED);
  }
 roboEyes.update(); // update eyes drawings
}